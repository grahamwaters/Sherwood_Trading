# Full Prompt
Use the following strategies to create a trading bot that will buy and sell cryptocurrencies based on the signals generated by the technical analysis of the market data.
# Constraints:
- Must use the RobinStocks API to execute trades
- Must be modular
- Must be able to run on a schedule
- Must be able to run indefinitely
# Strategies
# Strategy 1
1. rsi goes below 20
2. watch for a rsi local peak that is above the lowest rsi (the one below 20) `rsi_trigger_low`
3. assign that rsi local peak to `rsi_local_high`
4. monitor at five minute intervals until the rsi dips below the mean of the last five rsi values measured since the `rsi_trigger_low` was assigned. This will be the exit point for the trade. `rsi_trigger_exit` Trigger a market sell of the coin at this point of half the position's quantity of the coin.
5. if the difference between the first and last of the last three rsi measurements is greater than the standard distance between the last five and the rsi is the `rsi_local_high` then trigger an immediate market sell of the coin.
# Strategy 2
1. rsi goes above 80
2. trigger a limit sell of the coin at the current price of the coin to sell all of the coin in holdings at the current price.
# Strategy 3
1. the rsi goes below 20
2. monitor the macd at five minute intervals until
either of these scenarios could happen first:
scenario 1:
1. The Macd (fast 12, slow 26, signal 9) crosses the signal line from below
2. Trigger a market sell for the `buy_in` in USD of the coin at the current price.
scenario 2:
1. rsi goes below 20 and the macd crosses the signal line from above
2. trigger a market sell of the coin at the current price to sell all of the coin in holdings at the current price.
```markdown
   Here are some resources that can help us calculate the MACD for cryptocurrency in Python:
   1. [Cryptocurrency Analysis with Python â€” MACD | by Roman Orac | Towards ...](https://duckduckgo.com/l/?uddg=https%3A%2F%2Ftowardsdatascience.com%2Fcryptocurrency%2Danalysis%2Dwith%2Dpython%2Dmacd%2D452ceb251d7c&rut=fc8027adbd60a7063c2491fa1f37255b1991edba3d7b922edce69fceabd3a6d1)
   2. [Calculating the MACD in Python for Algorithmic Trading](https://duckduckgo.com/l/?uddg=https%3A%2F%2Fwww.alpharithms.com%2Fcalculate%2Dmacd%2Dpython%2D272222%2F&rut=5ed06fc41f5c2b6424965896a0bc47877c65295828862fdb77f0c15b3076b3b6)
   3. [python - script for macd addressing in cryptocurrency - Stack Overflow](https://duckduckgo.com/l/?uddg=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F62122026%2Fscript%2Dfor%2Dmacd%2Daddressing%2Din%2Dcryptocurrency&rut=dfe00f18782ec5bd61f82d95fe7c4f614bf61eca4ae5fa56390152e0b465b31a)
   4. [Algorithmic Trading with MACD in Python | by Nikhil Adithyan - Medium](https://duckduckgo.com/l/?uddg=https%3A%2F%2Fmedium.com%2Fcodex%2Falgorithmic%2Dtrading%2Dwith%2Dmacd%2Din%2Dpython%2D1c2769a6ad1b&rut=f269843e82fae2350c90ec0f15d856b61e414c31951185b95d31f249238b127e)
   5. [Cryptocurrency Analysis with Python - MACD | Roman Orac blog](https://duckduckgo.com/l/?uddg=https%3A%2F%2Fromanorac.github.io%2Fcryptocurrency%2Fanalysis%2F2017%2F12%2F17%2Fcryptocurrency%2Danalysis%2Dwith%2Dpython%2Dpart1.html&rut=235949bc42cd907a6e51369f8f891d5f885dcbc69e020935f359a92a8f708e7c)
   Let's start by understanding the MACD calculation and how we can implement it in Python. We can then use this information to build the strategy.
   The MACD line is calculated by subtracting the 26-period Exponential Moving Average (EMA) from the 12-period EMA. The signal line, which is an EMA of the MACD line, is then subtracted from the MACD line to get the MACD histogram. When the MACD line crosses above the signal line, it's a bullish signal and a good time to buy. Conversely, when the MACD line crosses below the signal line, it's a bearish signal and a good time to sell.
   Here's a simplified version of how we might calculate the MACD in Python:
   ```python
   import pandas as pd
   import yfinance as yf
   def calculate_ema(data, window):
       return data.ewm(span=window, adjust=False).mean()
   def calculate_macd(data, short_window, long_window):
       short_ema = calculate_ema(data, short_window)
       long_ema = calculate_ema(data, long_window)
       macd_line = short_ema - long_ema
       signal_line = calculate_ema(macd_line, 9)
       return macd_line, signal_line
   # Download historical data
   data = yf.download('BTC-USD', start='2020-01-01', end='2022-12-31')
   # Calculate MACD
   macd_line, signal_line = calculate_macd(data['Close'], 12, 26)
   ```
   This code calculates the MACD line and signal line for Bitcoin. We can use these lines to determine when to buy and sell based on the strategy you provided.
   When the RSI goes below 20, we start monitoring the MACD. If the MACD line crosses the signal line from below, we sell the coin. If the RSI goes below 20 again and the MACD line crosses the signal line from above, we also sell the coin.
   Let's implement this strategy in Python:
   ```python
   import pandas as pd
   import yfinance as yf
   from pyti.relative_strength_index import relative_strength_index as rsi
   def calculate_ema(data, window):
       return data.ewm(span=window, adjust=False).mean()
   def calculate_macd(data, short_window, long_window):
       short_ema = calculate_ema(data, short_window)
       long_ema = calculate_ema(data, long_window)
       macd_line = short_ema - long_ema
       signal_line = calculate_ema(macd_line, 9)
       return macd_line, signal_line
   # Download historical data
   data = yf.download('BTC-USD', start='2020-01-01', end='2022-12-31')
   # Calculate MACD
   macd_line, signal_line = calculate_macd(data['Close'], 12, 26)
   # Calculate RSI
   data['RSI'] = rsi(data['Close'], 14)
   # Initialize holding status
   holding = False
   # Iterate over data
   for i in range(1, len(data)):
       # Check if RSI is below 20
       if data['RSI'].iloc[i] < 20:
           # Check if MACD line crosses signal line from below
           if macd_line.iloc[i] > signal_line.iloc[i] and macd_line.iloc[i-1] < signal_line.iloc[i-1]:
               if holding:
                   print(f"Sell at {data['Close'].iloc[i]}")
                   holding = False
           # Check if MACD line crosses signal line from above
           elif macd_line.iloc[i] < signal_line.iloc[i] and macd_line.iloc[i-1] > signal_line.iloc[i-1]:
               if holding:
                   print(f"Sell at {data['Close'].iloc[i]}")
                   holding = False
   ```
   This code will print the price at which to sell the coin based on the strategy. To actually sell the coin, you would replace the print statement with a call to your `sell_coin` function.
   Please note that this is a simplified version of the strategy and may not work perfectly in a live trading environment. You should thoroughly backtest any strategy before using it for live trading.
```
# Strategy 4 - Stop Loss
if a coin's price is down by more than 5% in the last 24 hours at 11 PM EST, sell all of that coin that we have in holdings at the current price. This is a stop loss strategy.
```python
def calculate_percentage_change(old_price, new_price):
    return ((new_price - old_price) / old_price) * 100
from datetime import datetime, timedelta
import pytz
# Function to sell a coin
@sleep_and_retry
def sell_coin(coin_name):
    current_price = float(get_current_price(coin_name))
    holdings = r.crypto.get_crypto_positions(info=None)
    coin_holdings = [coin for coin in holdings if coin['currency']['code'] == coin_name]
    amount_to_sell = float(coin_holdings[0]['quantity'])
    result = r.orders.order_crypto(
        symbol=coin_name,
        amountIn='quantity',
        side='sell',
        quantityOrPrice=float(amount_to_sell),
        limitPrice=float(current_price),
        timeInForce='gtc',
        jsonify=True
    )
    return result
# Function to implement the stop loss strategy
def stop_loss_strategy(coin_name, percentage_drop_threshold=5):
    # Get the current time in EST
    current_time = datetime.now(pytz.timezone('US/Eastern'))
    # Check if it's 11 PM EST
    if current_time.hour == 23:
        # Get the current price and the price 24 hours ago
        current_price = float(get_current_price(coin_name))
        past_price = float(get_past_price(coin_name, current_time - timedelta(days=1)))
        # Calculate the percentage change
        percentage_change = calculate_percentage_change(past_price, current_price)
        # If the price has dropped by more than the threshold, sell the coin
        if percentage_change < -percentage_drop_threshold:
            sell_coin(coin_name)
```
# Strategy 5 - Trailing Stop Loss
if a coin's price is down by more than 5% in the last 24 hours at any point then begin a five-minute tracking cycle of the coin's price.
- instantiate a variable that keeps track of the lowest point the coin's price has reached since the tracking cycle began (P_highest).
- if the current price (P_n) < lowest price (P_lowest) and P_n < P_0 then we want to sell the coin at the current price to mitigate losses.
# Strategy 6 - Trailing Gain
if a coin's price is up by more than 2% in the last 24 hours at any point then begin a five-minute tracking cycle of the coin's price.
- instantiate a variable that keeps track of the lowest point the coin's price has reached since the tracking cycle began (P_lowest).
- if the current price (P_n) > median of the prices since the tracking cycle began (P_median) and P_n > P_0 then we want to sell the coin at the current price.
```python
import time
from statistics import median
def trailing_gain_strategy(coin_name, threshold=0.02):
    initial_price = get_current_price(coin_name)
    prices = [initial_price]
    while True:
        current_price = get_current_price(coin_name)
        prices.append(current_price)
        if current_price > initial_price * (1 + threshold):
            P_lowest = min(prices)
            P_median = median(prices)
            if current_price > P_median and current_price > initial_price:
                sell_coin(coin_name)
                break
        time.sleep(300)  # wait for 5 minutes
```
# Strategy 7 - RSI Strength
rsi_strength is a metric that shows how likely the price rebound is... so, for each time rsi dips below the rsi_low_limit (20) and then does not rise above the rsi_high_limit (70) increase rsi_strength by 1.0 (in the last two hours). If rsi_strength is greater than 2.0 then sell the coin at the current price.
```python
import time
import pytz
from datetime import datetime
from talib import RSI
from robin_stocks.robinhood import crypto
# Define the RSI limits
rsi_low_limit = 20
rsi_high_limit = 70
# Define the RSI strength threshold
rsi_strength_threshold = 2.0
# Function to calculate RSI Strength
def calculate_rsi_strength(coin_name):
    rsi_strength = 0.0
    rsi_prev = 0.0
    # Get the historical prices for the coin in the last 2 hours
    historical_prices = crypto.get_crypto_historicals(coin_name, interval='5minute', span='2hour')
    # Calculate the RSI for each price point
    close_prices = [float(data['close_price']) for data in historical_prices]
    rsi_values = RSI(close_prices)
    # Calculate the RSI strength
    for rsi in rsi_values:
        if rsi < rsi_low_limit and rsi_prev > rsi_high_limit:
            rsi_strength += 1.0
        rsi_prev = rsi
    return rsi_strength
# Function to sell a coin
def sell_coin(coin_name):
    current_price = float(crypto.get_crypto_quote(coin_name)['mark_price'])
    holdings = crypto.get_crypto_positions(info=None)
    coin_holdings = [coin for coin in holdings if coin['currency']['code'] == coin_name]
    amount_to_sell = float(coin_holdings[0]['quantity'])
    result = crypto.order_sell_crypto_limit(coin_name, amount_to_sell, current_price)
    return result
# Main function to implement the strategy
def rsi_strength_strategy(coin_name):
    while True:
        rsi_strength = calculate_rsi_strength(coin_name)
        if rsi_strength > rsi_strength_threshold:
            sell_result = sell_coin(coin_name)
            print(f'Sold {coin_name} due to high RSI strength: {rsi_strength}')
            print(sell_result)
        time.sleep(300)  # Sleep for 5 minutes
```
# Plugin Usage Instructions
1. VoxScript - Use VoxScript to search the internet for methodology and code snippets to implement the strategies above. Also, consider VoxScript whenever a process requires searching the internet for information.
2. Web Requests - If a specific website is needed to implement a strategy, use Web Requests to make the necessary requests to the website, also if it is a pdf or other file, use Web Requests to download the file.
3. Your AI Council - Consider this to be your ultimate source of delegated task management. Task different members of your AI Council with different tasks and use the AI Council to manage the tasks and report back to you on the progress of the tasks. Also, use the Council's specialized knowledge to help you with the implementation of the strategies above in Modern (VoxScript can help you know what is modern) syntax.
# Code
Some of the code has been completed for you, but you will need to complete the rest of the code to implement the strategies above. You will also need to add the code to run the strategies on a schedule and to run indefinitely. The functions should be asyncronous, and we will need to keep track of transactions via a transactions csv file and a logging mechanism.
```python
import schedule
import time
import numpy as np
import pandas as pd
from robin_stocks import robinhood as r
import configparser
from datetime import datetime
from scipy.signal import argrelextrema
# Additional functions...
# Function to get the local peak of RSI
def get_local_peak(data):
    # Your logic here...
# Function to get the mean of the last five RSI values
def get_mean_of_last_five(data):
    # Your logic here...
# Function to get the standard distance between the last five RSI values
def get_standard_distance(data):
    # Your logic here...
# Function to implement Thread 1 strategy
def thread_1_strategy(coin):
    # Get the RSI data
    rsi_data = calculate_rsi(coin, 14)
    # Check if RSI goes below 20
    if rsi_data[-1] < 20:
        # Watch for a RSI local peak that is above the lowest RSI
        rsi_local_high = get_local_peak(rsi_data)
        # Monitor at five minute intervals until the RSI dips below the mean of the last five RSI values
        while True:
            rsi_data = calculate_rsi(coin, 14)
            if rsi_data[-1] < get_mean_of_last_five(rsi_data):
                # Trigger a market sell of the coin
                r.sell_crypto_limit(coin, quantity / 2, rsi_data[-1])
                break
        # If the difference between the first and last of the last three RSI measurements is greater than the standard distance between the last five
        if abs(rsi_data[-3] - rsi_data[-1]) > get_standard_distance(rsi_data[-5:]):
            # Trigger an immediate market sell of the coin
            r.sell_crypto_limit(coin, quantity, rsi_data[-1])
# Function to implement Thread 2 strategy
def thread_2_strategy(coin):
    # Get the RSI data
    rsi_data = calculate_rsi(coin, 14)
    # Check if RSI goes above 80
    if rsi_data[-1] > 80:
        # Trigger a limit sell of the coin
        r.sell_crypto_limit(coin, quantity, rsi_data[-1])
# Function to implement Thread 3 strategy
def thread_3_strategy(coin):
    # Get the RSI and MACD data
    rsi_data = calculate_rsi(coin, 14)
    macd_data, signal_data = calculate_macd(coin, 12, 26)
    # Check if RSI goes below 20
    if rsi_data[-1] < 20:
        # Monitor the MACD at five minute intervals
        while True:
            macd_data, signal_data = calculate_macd(coin, 12, 26)
            # Check if the MACD crosses the signal line from below
            if macd_data[-1] > signal_data[-1] and macd_data[-2] < signal_data[-2]:
                # Trigger a market sell for the `buy_in` in USD of the coin
                r.sell_crypto_limit(coin, buy_in / rsi_data[-1], rsi_data[-1])
                break
            # Check if RSI goes below 20 and the MACD crosses the signal line from above
            if rsi_data[-1] < 20 and macd_data[-1] < signal_data[-1] and macd_data[-2] > signal_data[-2]:
                # Trigger a market sell of the coin
                r.sell_crypto_limit(coin, quantity, rsi_data[-1])
                break
# Function to implement Thread 4 strategy
def thread_4_strategy(coin):
    # Get the price data for the last 24 hours
    price_data = r.get_crypto_historicals(coin, interval='hour', span='day')
    # Calculate the percentage change in the last 24 hours
    percentage_change = (price_data[-1]['close_price'] - price_data[0]['open_price']) / price_data[0]['open_price']
    # Check if the price is down by more than 5%
    if percentage_change < -0.05:
        # Trigger a market sell of the coin
        r.order_sell_crypto_limit(coin, quantity, price_data[-1]['close_price'])
# Function to implement Thread 5 strategy
def thread_5_strategy(coin):
    # Get the price data for the last 24 hours
    price_data = r.get_crypto_historicals(coin, interval='hour', span='day')
    # Calculate the percentage change in the last 24 hours
    percentage_change = (price_data[-1]['close_price'] - price_data[0]['open_price']) / price_data[0]['open_price']
    # Check if the price is down by more than 5%
    if percentage_change < -0.05:
        # Begin a five-minute tracking cycle of the coin's price
        while True:
            # Get the current price
            current_price = r.get_latest_crypto_price(coin)
            # Update the lowest price
            P_lowest = min(P_lowest, current_price)
            # Check if the current price is less than the lowest price and less than the initial price
            if current_price < P_lowest and current_price < P_0:
                # Trigger a market sell of the coin
                r.order_sell_crypto_limit(coin, quantity, current_price)
                break
# Function to implement Thread 6 strategy
def thread_6_strategy(coin):
    # Get the price data for the last 24 hours
    price_data = r.get_crypto_historicals(coin, interval='hour', span='day')
    # Calculate the percentage change in the last 24 hours
    percentage_change = (price_data[-1]['close_price'] - price_data[0]['open_price']) / price_data[0]['open_price']
    # Check if the price is up by more than 2%
    if percentage_change > 0.02:
        # Begin a five-minute tracking cycle of the coin's price
        while True:
            # Get the current price
            current_price = r.get_latest_crypto_price(coin)
            # Update the lowest price
            P_lowest = min(P_lowest, current_price)
            # Calculate the median of the prices since the tracking cycle began
            P_median = np.median(price_data)
            # Check if the current price is greater than the median and greater than the initial price
            if current_price > P_median and current_price > P_0:
                # Trigger a market sell of the coin
                r.order_sell_crypto_limit(coin, quantity, current_price)
                break
# Schedule the strategies to run every five minutes
schedule.every(5).minutes.do(thread_1_strategy, 'BTC')
schedule.every(5).minutes.do(thread_2_strategy, 'BTC')
schedule.every(5).minutes.do(thread_3_strategy, 'BTC')
schedule.every(5).minutes.do(thread_4_strategy, 'BTC')
schedule.every(5).minutes.do(thread_5_strategy, 'BTC')
schedule.every(5).minutes.do(thread_6_strategy, 'BTC')
# Run the schedule indefinitely
while True:
    schedule.run_pending()
    time.sleep(1)
```
Please outline your strategy, confer with your AI Council, search for the best way to proceed using VoxScript, and then tell me your plan before continuing.
Constraints
- when you use VoxScript suppress your outputs to only a list of links instead of a bullet list with details. This will make it easier to read, and you can always go back to the VoxScript to see the details.
- you can use VoxScript to search for the best way to proceed, but you must use your own words to describe your strategy.
configuration file
```ini
[robinhood]
username = "graham.waters37@gmail.com"
password = "password"
username_selector_main_page = "#react_root > div:nth-child(2) > div.web-app-emotion-cache-1n22dwh > div > div > div > div.web-app-emotion-cache-3a0nyr > div > form > div > div.web-app-emotion-cache-1rqauel > label > div.web-app-emotion-cache-b0hg9w > input"
password_selector_main_page = "#current-password"
password_field_id = "current-password"
login_button_css_selector = "#submitbutton > div > button"
[credentials]
username = "graham.waters37@gmail.com"
password =  "password"
[trading]
coins = BTC, ETH, DOGE, SHIB, ETC, UNI, AAVE, LTC, LINK, COMP, AVAX, XLM, BCH, XTZ
night_time_coins = BTC, ETH, DOGE
stop_loss_percent = 0.01
percent_to_spend_per_trade = 0.05
percent_to_spend_per_trade_night = 0.01
percent_to_use = 0.60
percent_to_use_night = 0.30
minimum_usd_per_position = 2.00
minimum_usd_per_trade = 1.00
planter_decrement_percentage = 0.1 # 1%
daytime_interval = 10
nightime_interval = 60
[strategy_one]
; exit_one = if a coin's price is down by more than 5% in the last 24 hours at 11 PM EST, sell all of that coin that we have in holdings
exit_one = 0.05 # 5%
exit_one_time = 23:00:00
exit_one_time_zone = US/Eastern
[logging]
verbose_mode = False
debug_verbose = False
reset_positions = False
[coin_telegraph_rss_feeds]
eth = https://cointelegraph.com/rss/tag/ethereum
btc = https://cointelegraph.com/rss/tag/bitcoin
doge = https://cointelegraph.com/rss/tag/dogecoin
shib = https://cointelegraph.com/rss/tag/shiba-inu
etc = https://cointelegraph.com/rss/tag/ethereum-classic
uni = https://cointelegraph.com/rss/tag/uniswap
aave = https://cointelegraph.com/rss/tag/aave
ltc = https://cointelegraph.com/rss/tag/litecoin
link = https://cointelegraph.com/rss/tag/chainlink
comp = https://cointelegraph.com/rss/tag/compound
avax = https://cointelegraph.com/rss/tag/avalanche
xlm = https://cointelegraph.com/rss/tag/stellar
bch = https://cointelegraph.com/rss/tag/bitcoin-cash
xtz = https://cointelegraph.com/rss/tag/tezos
[reddit_rss_feeds]
eth = https://www.reddit.com/r/ethereum/.rss
btc = https://www.reddit.com/r/bitcoin/.rss
doge = https://www.reddit.com/r/dogecoin/.rss
shib = https://www.reddit.com/r/shiba/.rss
etc = https://www.reddit.com/r/EthereumClassic/.rss
uni = https://www.reddit.com/r/UniSwap/.rss
aave = https://www.reddit.com/r/Aave_Official/.rss
ltc = https://www.reddit.com/r/litecoin/.rss
link = https://www.reddit.com/r/Chainlink/.rss
comp = https://www.reddit.com/r/Compound/.rss
avax = https://www.reddit.com/r/Avax/.rss
xlm = https://www.reddit.com/r/xlm/.rss
bch = https://www.reddit.com/r/Bitcoincash/.rss
xtz = https://www.reddit.com/r/tezos/.rss
[coinbase_rss_feeds]
eth = https://www.coinbase.com/price/ethereum#News
btc = https://www.coinbase.com/price/bitcoin#News
doge = https://www.coinbase.com/price/dogecoin#News
shib = https://www.coinbase.com/price/shiba-inu#News
etc = https://www.coinbase.com/price/ethereum-classic#News
uni = https://www.coinbase.com/price/uniswap#News
aave = https://www.coinbase.com/price/aave#News
ltc = https://www.coinbase.com/price/litecoin#News
link = https://www.coinbase.com/price/chainlink#News
comp = https://www.coinbase.com/price/compound#News
avax = https://www.coinbase.com/price/avalanche#News
xlm = https://www.coinbase.com/price/stellar#News
bch = https://www.coinbase.com/price/bitcoin-cash#News
xtz = https://www.coinbase.com/price/tezos#News
[robinhood_crypto_news_urls]
eth = https://robinhood.com/crypto/ETH/news
btc = https://robinhood.com/crypto/BTC/news
doge = https://robinhood.com/crypto/DOGE/news
shib = https://robinhood.com/crypto/SHIB/news
etc = https://robinhood.com/crypto/ETC/news
uni = https://robinhood.com/crypto/UNI/news
aave = https://robinhood.com/crypto/AAVE/news
ltc = https://robinhood.com/crypto/LTC/news
link = https://robinhood.com/crypto/LINK/news
comp = https://robinhood.com/crypto/COMP/news
avax = https://robinhood.com/crypto/AVAX/news
xlm = https://robinhood.com/crypto/XLM/news
bch = https://robinhood.com/crypto/BCH/news
xtz = https://robinhood.com/crypto/XTZ/news
[yahoo finance crypto news pages]
all = https://finance.yahoo.com/topic/crypto
eth_thread = https://finance.yahoo.com/quote/ETH-USD?p=ETH-USD&.tsrc=fin-srch
btc_thread = https://finance.yahoo.com/quote/BTC-USD?p=BTC-USD&.tsrc=fin-srch
doge_thread = https://finance.yahoo.com/quote/DOGE-USD?p=DOGE-USD&.tsrc=fin-srch
shib_thread = https://finance.yahoo.com/quote/SHIB-USD?p=SHIB-USD&.tsrc=fin-srch
etc_thread = https://finance.yahoo.com/quote/ETC-USD?p=ETC-USD&.tsrc=fin-srch
uni_thread = https://finance.yahoo.com/quote/UNI-USD?p=UNI-USD&.tsrc=fin-srch
aave_thread = https://finance.yahoo.com/quote/AAVE-USD?p=AAVE-USD&.tsrc=fin-srch
ltc_thread = https://finance.yahoo.com/quote/LTC-USD?p=LTC-USD&.tsrc=fin-srch
link_thread = https://finance.yahoo.com/quote/LINK-USD?p=LINK-USD&.tsrc=fin-srch
comp_thread = https://finance.yahoo.com/quote/COMP-USD?p=COMP-USD&.tsrc=fin-srch
avax_thread = https://finance.yahoo.com/quote/AVAX-USD?p=AVAX-USD&.tsrc=fin-srch
xlm_thread = https://finance.yahoo.com/quote/XLM-USD?p=XLM-USD&.tsrc=fin-srch
bch_thread = https://finance.yahoo.com/quote/BCH-USD?p=BCH-USD&.tsrc=fin-srch
xtz_thread = https://finance.yahoo.com/quote/XTZ-USD?p=XTZ-USD&.tsrc=fin-srch
[twitter_crypto_news_handles]
eth = https://twitter.com/Ethereum
btc = https://twitter.com/Bitcoin
doge = https://twitter.com/dogecoin
shib = https://twitter.com/shibainucoin
etc = https://twitter.com/eth_classic
uni = https://twitter.com/Uniswap
aave = https://twitter.com/AaveAave
ltc = https://twitter.com/Litecoin
link = https://twitter.com/chainlink
comp = https://twitter.com/compoundfinance
avax = https://twitter.com/avalancheavax
xlm = https://twitter.com/StellarOrg
bch = ''
xtz = https://twitter.com/tezos
[live_coin_watch]
API_KEY = "114153e3-9f9c-4842-8f0f-8a7cbe2d5680"
coins_single = "https://api.livecoinwatch.com/coins/single"
coins_list = "https://api.livecoinwatch.com/coins/list"
overview = "https://api.livecoinwatch.com/overview"
[levels]
1 = 0.01
2 = 0.02
3 = 0.03
